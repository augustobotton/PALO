\chapter{Implementação}

\section{Implementação Aula 2}

A implementação do exemplo 3.1 mostrado na aula 2 utilizando Python, é divida nas seguintes etapas:

\begin{itemize}
    \item O script principal importa vários módulos e pacotes, incluindo 'parametros', 'numpy', 'matplotlib.pyplot', e 'gravidade-axissim'. O módulo 'parametros' fornece um espaço para armazenar variáveis globais, enquanto 'gravidade-axissim' contém a função que calcula a gravidade axissimétrica da Terra;
    \item No script principal, são definidas várias constantes relacionadas à Terra, incluindo o raio equatorial da Terra (Re), a constante de gravitação universal (G), a massa da Terra (M), e as constantes de Jeffery (J2, J3, J4). Essas constantes são armazenadas no módulo 'parametros' para uso posterior;
    \item O script principal cria um vetor 'h' contendo 100 valores igualmente espaçados entre 0 e 200 km, que representam diferentes altitudes acima da superfície da Terra. O vetor 'delta' é definido como 'h - 100', representando a latitude em graus;
    
    \item No script principal, 'h' é convertido para metros e adicionado ao raio da Terra para obter a distância radial 'r'. 'delta' é convertido para radianos e subtraído de pi/2 para obter a colatitude 'phi';
    
    \item Para cada valor em 'h', o script principal calcula a gravidade 'g' usando o modelo esférico. A função 'grav-axissimetrico' do script 'gravidade-axissim' é chamada para calcular a gravidade axissimétrica. Ela recebe 'r' e 'phi' como argumentos e retorna as componentes radial e colatitudinal da gravidade (gr e gphi). Dentro da função 'grav-axissimetrico', as constantes do módulo 'parametros' são usadas para compartilhar variáveis globais; 
    
    \item Por fim, o script principal plota os resultados em dois gráficos. O primeiro gráfico mostra a gravidade calculada pelos modelos esférico e axissimétrico em função da latitude. O segundo gráfico mostra a componente colatitudinal da gravidade calculada pelo modelo axissimétrico, também em função da latitude.
\end{itemize}

\section{Implementação Aula 6}

A implementação dos exemplos mostrados na aula 6 utilizando Python, é divida nas seguintes etapas:

\begin{itemize}
    \item O script resolveEqBarker calcula a anomalia verdadeira de uma órbita parabólica com base no tempo fornecido como entrada. Ele utiliza parâmetros definidos em um arquivo chamado "parametros.py" (no qual os parâmetros são dados como nulos inicialmente) e faz uso da biblioteca NumPy para realizar cálculos matemáticos. A função utiliza fórmulas matemáticas específicas para calcular a anomalia média parabólica, a solução analítica e, por fim, a anomalia verdadeira. O resultado final, representado pela variável theta, é retornado como saída da função em radianos;
    \item O script com funções Kepler e resolveEqKepler resolve a equação de Kepler utilizando a anomalia excêntrica como incógnita e parâmetros adicionais, após isso, calcula a anomalia excêntrica para um tempo específico em uma órbita elíptica. Ela extrai os parâmetros relevantes, calcula a anomalia média e, em seguida, utiliza a função fsolve para resolver numericamente a equação de Kepler. O resultado retornado é a anomalia excêntrica correspondente ao tempo fornecido;
    \item Em outro script, a função KeplerHiperbolica resolve a equação de Kepler hiperbólica, utilizando a anomalia hiperbólica (H) como a incógnita e parâmetros adicionais (e, Mh). A equação é resolvida através do cálculo da função objetivo (y), que é uma combinação da excentricidade (e), do seno hiperbólico de H, de H e de Mh. Quando y é igual a zero, a equação de Kepler hiperbólica está resolvida. Já a função resolveEqKeplerHiperbolica calcula a anomalia hiperbólica para um determinado tempo (t) em uma órbita hiperbólica. Ela utiliza os parâmetros definidos em "parametros.py" e as bibliotecas NumPy e scipy.optimize. A função extrai os parâmetros relevantes, como o tempo de periastro (tau), o parâmetro (p), a constante gravitacional do planeta (mu) e a excentricidade da órbita (e). Em seguida, calcula a anomalia média hiperbólica (Mh) com base no tempo fornecido. Os parâmetros adicionais (e, Mh) são passados para a função fsolve juntamente com o valor inicial (H0) para a anomalia hiperbólica. A função fsolve utiliza a função KeplerHiperbolica para resolver numericamente a equação de Kepler hiperbólica e encontrar a anomalia hiperbólica (H) correspondente ao tempo fornecido. O resultado, H, é retornado pela função resolveEqKeplerHiperbolica; 
    \item O script com a função matrizTransicaoEstado calcula a matriz de transição de estado. A função recebe a anomalia verdadeira como entrada e utiliza parâmetros definidos em um arquivo externo. Ela realiza os cálculos necessários para determinar as constantes associadas à órbita, como o momento angular específico e a distância radial inicial. Em seguida, utiliza essas constantes para calcular os coeficientes de Lagrange. A matriz de transição de estado é então construída a partir desses coeficientes e retornada como resultado da função. Em resumo, a função matrizTransicaoEstado calcula e retorna a matriz de transição de estado com base na anomalia verdadeira fornecida;
    \item O script principal começa importando os módulos necessários. Em seguida, algumas constantes gerais são definidas, como a constante de gravitação universal, a massa da Terra e o raio equatorial da Terra. As condições iniciais dos exemplos também são definidas, como a anomalia verdadeira inicial e o tempo de periastro. O script possui exemplos de aplicação em órbita elíptica, órbita hiperbólica e órbita parabólica. Para cada exemplo, são definidos parâmetros específicos, como a distância de periastro, excentricidade e semi-eixo maior. Em seguida, são realizados cálculos para determinar o período da órbita, vetor de tempo, vetores de posição e velocidade inicial, e matrizes que armazenarão a solução. A propagação da órbita é feita para cada instante de tempo, resolvendo equações de Kepler específicas para cada tipo de órbita. A matriz de transição de estado é determinada a partir da anomalia verdadeira, e a posição e velocidade são calculadas usando essa matriz. Finalmente, são plotados gráficos ilustrando os resultados para cada exemplo de órbita. Os gráficos incluem a variação da anomalia excedente/verdadeira, componentes da velocidade, e a trajetória orbital em coordenadas retangulares. No final do script, é exibido um gráfico para cada exemplo de órbita: órbita elíptica, órbita hiperbólica e órbita parabólica. Cada gráfico mostra a variação da anomalia verdadeira, as componentes da velocidade e a trajetória orbital.
\end{itemize}

\section{Implementação Aula 8}

A implementação dos exemplos mostrados na aula 8 utilizando Python, é divida nas seguintes etapas:

\begin{itemize}
    \item O script recebe os argumentos que representam o tempo da observação, o vetor posição relativa, o vetor velocidade relativa e o parâmetro gravitacional. A função realiza uma série de cálculos matemáticos para determinar os parâmetros orbitais com base nas informações fornecidas. Esses parâmetros descrevem a órbita dos corpos no espaço. Os cálculos incluem a determinação da distância radial no instante observado, o vetor quantidade de movimento angular específica no referencial celeste, o vetor excentricidade no referencial celeste, a excentricidade da órbita, o módulo do vetor quantidade de movimento angular, o parâmetro da órbita e o semi eixo maior;

    \item São calculados a anomalia verdadeira no instante da observação e o tipo de órbita com base na excentricidade. O tempo de periastro é então calculado levando em consideração o tipo de órbita: elíptica, parabólica ou hiperbólica;
    
    \item O código determina a linha dos nodos, o vetor unitário ao longo dessa linha (no sistema celeste), a longitude celeste do nodo ascendente e a inclinação da órbita;

    \item Por fim, são calculados o vetor unitário ao longo do vetor excentricidade (no referencial celeste), o vetor unitário ao longo do vetor quantidade de movimento angular (no referencial celeste) e o argumento de periastro. Todos esses parâmetros são armazenados em um vetor chamado par-orb, que contém seis elementos: semi eixo maior (a), excentricidade (e), tempo de periastro (tau), longitude celeste do nodo ascendente (OMEGA), inclinação (i) e argumento de periastro (omega);
    \item Em outro script, é resolvido o exemplo 5.2, no qual são calculados os parâmetros orbitais com base em uma observação de posição e velocidade no espaço. Os valores de exemplo para a posição, velocidade e parâmetro gravitacional são fornecidos, e os parâmetros orbitais são calculados e impressos na tela utilizando o script principal. 
\end{itemize}

\section{Implementação Aula 10}

Para os exemplos realizados na aula 10, é escrito um código para cada exemplo: 

\begin{itemize}
    \item Exemplo 5.6: Inicialmente são estabelecidas as constantes do problema, como o raio da Terra, a constante gravitacional e as características das órbitas inicial e final. Então, são calculados as distâncias radiais da órbita inicial, de perigeu da órbita final e de apogeu da órbita final. Nesse momento, calcula-se o semi eixo maior final, a velocidade da nova órbita, a excentricidade da nova órbita, o parâmetro da nova órbita e a altitude da nova órbita. Após isso, é calculado o ângulo de trajetória da órbita resultante no ponto de manobra. Então, com a equação da energia é encontrado a velocidade inicial da órbita, com a qual se define o primeiro impulso de velocidade e posteriormente o ângulo entre a velocidade inicial e o primeiro impulso. Para o segundo impulso, se define a variação requerida da inclinação para a manobra, e de forma similar ao feito anteriormente, se define a velocidade inicial da nova órbita, com a qual se define o segundo impulso e também o ângulo entre a velocidade e o mesmo;
    
    \item Exemplo 5.7: Primeiro, são importados os pacotes necessários e definidos a constante gravitacional da Terra e os parâmetros da órbita inicial. Então, define-se a direção do impulso de velocidade e calcula-se a velocidade no apogeu e a magnitude do impulso de velocidade necessário para a manobra. Assim, são estabelecidos os vetores posição e velocidade no ponto de manobra, além do vetor de quantidade de movimento angular específica da órbita inicial, todos no referencial perifocal inicial. Depois, calcula-se o vetor impulso de velocidade necessário para a manobra no referencial perifocal inicial, e o vetor velocidade resultante após a manobra. É definida uma matriz de transformação de coordenadas do referencial perifocal da órbita inicial para o referencial celeste, e transforma os vetores envolvidos na manobra para este referencial. O vetor posição na órbita resultante no ponto de manobra é o mesmo que na órbita inicial. É usada a função det-orbita para determinar os elementos orbitais da órbita resultante e imprimir esses parâmetros. Por fim, calcula-se o ângulo entre os planos das órbitas inicial e final;

    \item Exemplo 5.8: Inicialmente, são definidos os dados inicias e os cálculos preliminares como raio equatorial, constante gravitacional, distância radial da órbita inicial, etc. Dado que a elipse 2 promove um abaixamento de órbita circular, ela é descartada, então é escolhida a elipse de transferência 1. Tem-se que o perigeu da órbita de transferência é coincidente com o raio da órbita circular, e o apogeu da órbita de transferência é coincidente com o apogeu da órbita elíptica desejada. Na sequência é calculado o semi eixo maior da elipse de transferência a partir do raio de perigeu e de apogeu da órbita de transferência. Então são calculadas as velocidades de apogeu e perigeu da órbita utilizando a equação da energia. Por fim, são definidas as velocidades no ponto de aplicação de impulso das órbitas inicial e final também a partir da equação de energia. O primeiro impulso é dado pela subtração da velocidade de perigeu da órbita de transferência com a velocidade no ponto de aplicação do impulso da órbita inicial, de forma similar, o segundo impulso é calculado subtraindo a velocidade de apogeu da órbita de transferência com a velocidade no ponto de aplicação de impulso da órbita final. O impulso total é dado pela soma do módulo dos dois impulsos definidos;

    \item Exemplo 5.9: São inseridos os dados do problema, seguido pelo cálculo do raio da órbita inicial. O raio final é dado pela manipulação da equação do tempo sideral. Os impulsos de velocidade são calculados pela equação de impulso de velocidade da transferência de Hommann. O tempo de transferência é obtido utilizando também uma das equações de Hommann.
\end{itemize}

\section{Implementação Aula 13}

Para os exemplos realizados na aula 13, é escrito um código para cada exemplo: 

\begin{itemize}
    \item Exemplo 6.1: Primeiramente são definidas as constantes, incluindo a constante gravitacional da Terra (mu), a segunda constante de Jeffery da Terra (J2), o raio equatorial da Terra (Re), e as propriedades da órbita desejada, incluindo o semieixo maior (a) e a excentricidade (e). Então é calculada a velocidade angular média da Terra em sua órbita ao redor do Sol (OMpm), primeiro em radianos por dia e depois em radianos por segundo. Depois, é calculada a velocidade angular média da órbita desejada (n) usando a terceira lei de Kepler. Posteriormente, é definido o parâmetro da órbita. Por fim, é calculada a inclinação necessária (inc) para que a órbita seja heliossíncrona, ou seja, para que ela mantenha uma orientação constante em relação ao Sol. O script então imprime essa inclinação em graus;
    
    \item Exemplo 6.2: Primeiro são importados os pacotes necessários, incluindo funções para a propagação da órbita Kepleriana, a determinação de elementos orbitais e a aplicação de perturbações devido ao terceiro corpo. Também define constantes globais para os parâmetros gravitacionais do Sol e da Terra. É definido o vetor de elementos orbitais da Terra em relação ao Sol e o vetor de estado inicial do veículo espacial (VE) - posição e velocidade. Define-se também uma função, dinPert3corpo, para calcular a dinâmica da massa de prova perturbada pelo terceiro corpo (a Terra). Esta função recebe como entrada o tempo e o vetor de estado do VE, e retorna as derivadas desse vetor. É utilizada a função solve-ivp do pacote scipy para integrar numericamente a equação de movimento perturbada pelo terceiro corpo ao longo de 100 dias solares médios. O resultado é a posição e velocidade do VE em cada ponto do tempo. Para comparação, o script também propaga a órbita do VE usando a solução analítica Kepleriana, que ignora a influência da Terra. Por fim, são comparados os resultados das duas simulações, integrada e Kepleriana, plotando a posição e velocidade do VE em cada componente (X, Y, Z) em função do tempo. Cada gráfico mostra duas curvas: uma para a solução integrada e outra para a solução Kepleriana.
\end{itemize}

\section{Implementação Aula 14}

Para os exemplos realizados na aula 14, é escrito um código para cada exemplo: 

\begin{itemize}
    \item Exemplo 7.3: Primeiramente, o código define uma função \textit{res3body} que contém as equações de movimento para o sistema. A massa do segundo primário é assumida como uma constante. As distâncias aos primários são calculadas, seguidas das equações de movimento. Em seguida, um vetor de tempo é definido, além de várias condições iniciais para a velocidade. Após definir a função e as condições iniciais, o código itera sobre a lista \textit{compvelocidade} com as condições iniciais de velocidade. Em cada iteração, a função \textit{solveivp} da biblioteca \textit{scipy} é usada para resolver o sistema de equações diferenciais ordinárias que descrevem o movimento. O método \textit{RK45} é usado para a resolução. Os resultados de cada simulação são então traçados em um gráfico de x contra y usando a biblioteca \textit{matplotlib}. Cada gráfico é título como "Trajetória da Espaçonave: Caso X", onde X varia de (a) a (g), correspondendo a cada configuração de velocidade inicial. Por fim, todos os gráficos são exibidos com a função \textit{plt.show()}. Infelizmente, as posições da Terra e da Lua não estão sendo plotadas, já que as linhas de código relevantes estão comentadas.
\end{itemize}

